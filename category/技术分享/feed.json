{
    "version": "https://jsonfeed.org/version/1",
    "title": "Work & Life • All posts by \"技术分享\" category",
    "description": "LC2808",
    "home_page_url": "https://chisato-lycoreco.github.io",
    "items": [
        {
            "id": "https://chisato-lycoreco.github.io/2022/08/26/tech/programming/python/python1/",
            "url": "https://chisato-lycoreco.github.io/2022/08/26/tech/programming/python/python1/",
            "title": "流言终结者之python性能优化技巧",
            "date_published": "2022-08-26T15:38:57.824Z",
            "content_html": "<h1 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h1>\n<p>最近搬砖的工作涉及到很多基础的 python 策略代码，因此一时兴起上网查了查 python 代码优化的方案。<br>\n本文一方面是汇总一些提升代码性能的编码技巧，更主要的是验证它们有效与否，顺便试着推理它们有效或者无效的原因。</p>\n<h1 id=\"列表生成式-2022826\"><a class=\"markdownIt-Anchor\" href=\"#列表生成式-2022826\">#</a> 列表生成式 （2022/8/26）</h1>\n<h2 id=\"应用场景\"><a class=\"markdownIt-Anchor\" href=\"#应用场景\">#</a> 应用场景</h2>\n<p>创建一个有规律的数组，并且为了实现这个规律不得不使用 for 循环的时候。例如：  <code>[1*1,2*2,3*3,...,n*n]</code>  , 其中  <code>n=1000</code>  。</p>\n<h2 id=\"传统方案-vs-列表生成式方案\"><a class=\"markdownIt-Anchor\" href=\"#传统方案-vs-列表生成式方案\">#</a> 传统方案 vs 列表生成式方案</h2>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"><span>传统方案</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>res <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    res<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>i<span class=\"token operator\">*</span>i<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>time elapsed<span class=\"token punctuation\">:</span><span class=\"token number\">0</span><span class=\"token punctuation\">.</span>127601s</pre></td></tr></table></figure><figure class=\"highlight python\"><figcaption data-lang=\"python\"><span>列表生成式方案</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>res <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>i<span class=\"token operator\">*</span>i <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">1000000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>time elapsed<span class=\"token punctuation\">:</span><span class=\"token number\">0</span><span class=\"token punctuation\">.</span>061128s</pre></td></tr></table></figure><p>结果显示，使用列表生成式的代码执行速度比使用 for 循环 append 快了不止一倍。而对于更大的 n 值，这一结论同样适用。<br>\n因此列表生成式在效率上的优势是显而易见的。<br>\n进一步地，在有 if 判断的场景下考察两者的差别。</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"><span>传统方案</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>res <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">if</span> i <span class=\"token operator\">%</span> <span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        res<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>i<span class=\"token operator\">*</span>i<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>time elapsed<span class=\"token punctuation\">:</span><span class=\"token number\">0</span><span class=\"token punctuation\">.</span>109248s</pre></td></tr></table></figure><figure class=\"highlight python\"><figcaption data-lang=\"python\"><span>列表生成式方案</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>res <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>i<span class=\"token operator\">*</span>i <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000000</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">if</span> i <span class=\"token operator\">%</span> <span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>time elapsed<span class=\"token punctuation\">:</span><span class=\"token number\">0</span><span class=\"token punctuation\">.</span>061044s</pre></td></tr></table></figure><p>不难发现，列表生成式方案的耗时几乎没有变化，而传统方案则明显变快了。<br>\n由此可以推断出一个结论，传统方案之所以慢是由于  <code>append()</code>  效率较低所致。<br>\n事实上，  <code>append()</code>  是一个时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> 的操作，它需要从头开始遍历整个数组的内存空间，直到到达数组尾部。<br>\n而创建列表时原地赋值则是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 时间复杂度的操作，差距显而易见。<br>\n在添加了  <code>if</code>  判断语句之后，虽然循环的次数没有变化，甚至还多了  <code>if</code>  判断的操作，但是  <code>append()</code>  的次数却显著减少了。</p>\n<h2 id=\"结论\"><a class=\"markdownIt-Anchor\" href=\"#结论\">#</a> 结论</h2>\n<ul>\n<li>列表生成式方法比 for-append 写法快得多。</li>\n<li>列表生成式方法之所以比 for-append 写法快，是由于  <code>append()</code>  的时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> ，而原地赋值的时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>。</li>\n</ul>\n<h1 id=\"内置函数\"><a class=\"markdownIt-Anchor\" href=\"#内置函数\">#</a> 内置函数</h1>\n<h1 id=\"生成器\"><a class=\"markdownIt-Anchor\" href=\"#生成器\">#</a> 生成器</h1>\n<h1 id=\"多重赋值\"><a class=\"markdownIt-Anchor\" href=\"#多重赋值\">#</a> 多重赋值</h1>\n<h1 id=\"itertools模块\"><a class=\"markdownIt-Anchor\" href=\"#itertools模块\">#</a>  <code>itertools</code>  模块</h1>\n<h1 id=\"lru-cache缓存\"><a class=\"markdownIt-Anchor\" href=\"#lru-cache缓存\">#</a> LRU Cache 缓存</h1>\n",
            "tags": [
                "python"
            ]
        }
    ]
}